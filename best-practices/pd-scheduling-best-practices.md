---
title: PD Scheduling Best Practices
summary: Learn best practice and strategy for PD scheduling.
---

# PD スケジューリングのベスト プラクティス {#pd-scheduling-best-practices}

このドキュメントでは、アプリケーションを容易にするために、一般的なシナリオを通じて PD スケジューリングの原則と戦略について詳しく説明します。このドキュメントは、TiDB、TiKV、および PD の基本的な知識があり、次の中心的な概念があることを前提としています。

-   [リーダー/フォロワー/学習者](/glossary.md#leaderfollowerlearner)
-   [オペレーター](/glossary.md#operator)
-   [オペレーターステップ](/glossary.md#operator-step)
-   [保留中/ダウン](/glossary.md#pendingdown)
-   [地域/ピア/Raftグループ](/glossary.md#regionpeerraft-group)
-   [リージョン分割](/glossary.md#region-split)
-   [スケジューラー](/glossary.md#scheduler)
-   [お店](/glossary.md#store)

> **ノート：**
>
> このドキュメントは、最初は TiDB 3.0 を対象としています。一部の機能は以前のバージョン (2.x) ではサポートされていませんが、基本的なメカニズムは類似しており、このドキュメントは参照として引き続き使用できます。

## PD スケジューリング ポリシー {#pd-scheduling-policies}

このセクションでは、スケジューリング システムに関連する原則とプロセスを紹介します。

### スケジューリングプロセス {#scheduling-process}

スケジューリング プロセスには、通常、次の 3 つの手順があります。

1.  情報を収集する

    各 TiKV ノードは定期的に 2 種類のハートビートを PD に報告します。

    -   `StoreHeartbeat` : ディスク容量、使用可能なストレージ、読み取り/書き込みトラフィックなど、ストアの全体的な情報が含まれます
    -   `RegionHeartbeat` : 各リージョンの範囲、ピアの分布、ピアのステータス、データ量、読み取り/書き込みトラフィックなど、リージョンの全体的な情報が含まれます

    PD は、スケジュール決定のためにこの情報を収集して復元します。

2.  オペレータの生成

    さまざまなスケジューラーが独自のロジックと要件に基づいてオペレーターを生成しますが、次の考慮事項があります。

    -   異常な状態 (切断、ダウン、ビジー、容量不足) のストアにピアを追加しないでください。
    -   異常な状態の領域をバランスさせない
    -   保留中のピアにリーダーを転送しない
    -   引出線を直接削除しないでください
    -   さまざまなリージョン ピアの物理的な分離を壊さないでください
    -   ラベル プロパティなどの制約に違反しない

3.  オペレーターの実行

    演算子を実行するための一般的な手順は次のとおりです。

    1.  生成されたオペレーターは、最初に`OperatorController`によって管理されるキューに参加します。

    2.  `OperatorController`は、オペレーターをキューから取り出し、構成に基づいて一定量の同時実行で実行します。このステップでは、各オペレーター ステップを対応する地域リーダーに割り当てます。

    3.  オペレーターは「終了」または「タイムアウト」としてマークされ、キューから削除されます。

### 負荷分散 {#load-balancing}

リージョンは、主に`balance-leader`または`balance-region`のスケジューラに依存して負荷分散を実現します。両方のスケジューラーは、クラスター内のすべてのストアに均等にリージョンを分散することをターゲットにして`balance-leader` `balance-region`が、別の焦点を当てています。 .

`balance-leader`と`balance-region`は同様のスケジューリング プロセスを共有します。

1.  リソースの可用性に応じてストアを評価します。
2.  `balance-leader`または`balance-region`は、スコアの高い店舗からスコアの低い店舗へリーダーまたはピアを常に移動させます。

ただし、評価方法は異なります。 `balance-leader`は店舗のリーダーに対応するすべての領域サイズの合計を使用しますが、 `balance-region`の方法は比較的複雑です。各ノードの特定のストレージ容量に応じて、評価方法`balance-region`は次のようになります。

-   十分なストレージがある場合のデータ量に基づきます (ノード間のデータ分散のバランスを取るため)。
-   ストレージが不十分な場合に使用可能なストレージに基づいて (異なるノードでストレージの可用性のバランスを取るため)。
-   どちらの状況にも当てはまらない場合は、上記の 2 つの要因の加重合計に基づいています。

ノードによってパフォーマンスが異なる場合があるため、ストアごとに負荷分散の重みを設定することもできます。 `leader-weight`と`region-weight`は、リーダーの重みと領域の重みをそれぞれ制御するために使用されます (両方のデフォルトで「1」)。例えば、店舗の`leader-weight`を「2」に設定すると、スケジューリングが安定した後、そのノードのリーダーの数は他のノードの約 2 倍になります。同様に、ストアの`leader-weight`を「0.5」に設定すると、ノードのリーダーの数は他のノードの約半分になります。

### ホット リージョンのスケジューリング {#hot-regions-scheduling}

ホット リージョンのスケジューリングには、 `hot-region-scheduler`を使用します。 TiDB v3.0 以降、プロセスは次のように実行されます。

1.  ストアから報告された情報に基づいて、特定の期間に特定のしきい値を超える読み取り/書き込みトラフィックを判断して、ホット リージョンをカウントします。

2.  ロード バランシングと同様の方法で、これらのリージョンを再配布します。

ホット ライト リージョンの場合、 `hot-region-scheduler`はリージョン ピアとリーダーの両方の再配布を試みます。ホット リード リージョンの場合、 `hot-region-scheduler`はリージョン リーダーのみを再配布します。

### クラスタトポロジの認識 {#cluster-topology-awareness}

クラスタトポロジの認識により、PD はリージョンのレプリカを可能な限り分散できます。これが、TiKV が高可用性と災害復旧機能を保証する方法です。 PD は、バックグラウンドですべての領域を継続的にスキャンします。 PD は、リージョンの分散が最適ではないことを検出すると、ピアを置き換えてリージョンを再分散する演算子を生成します。

リージョンの分散をチェックするコンポーネントは`replicaChecker`で、無効にできない点を除いてスケジューラに似ています。 `location-labels`の構成に基づく`replicaChecker`のスケジュール。たとえば、 `[zone,rack,host]`はクラスターの 3 層トポロジーを定義します。 PD は、リージョン ピアを最初に別のゾーンにスケジュールしようとします。ゾーンが不十分な場合は別のラックにスケジュールしようとします (たとえば、3 つのレプリカに対して 2 つのゾーン)。ラックが不十分な場合は別のホストにスケジュールしようとします。

### スケールダウンと障害復旧 {#scale-down-and-failure-recovery}

スケールダウンとは、ストアをオフラインにし、コマンドを使用して「オフライン」としてマークするプロセスを指します。 PD は、スケジューリングによって、オフライン ノード上のリージョンを他のノードに複製します。障害回復は、ストアに障害が発生して回復できない場合に適用されます。この場合、対応するストアにピアが分散されているリージョンはレプリカを失う可能性があり、他のノードで PD を補充する必要があります。

スケールダウンと障害回復のプロセスは基本的に同じです。 `replicaChecker`は、異常な状態のリージョン ピアを検出し、異常なピアを正常なストアの新しいピアに置き換える演算子を生成します。

### リージョンのマージ {#region-merge}

リージョン結合とは、隣接する小さな領域を結合するプロセスを指します。これは、データの削除後に多数の小さなリージョンまたは空のリージョンによって不要なリソースが消費されるのを回避するのに役立ちます。リージョンのマージは`mergeChecker`によって実行され、 `replicaChecker`と同様の方法で処理されます。PD はバックグラウンドですべての領域を継続的にスキャンし、連続する小さな領域が見つかったときに演算子を生成します。

具体的には、新しく分割されたリージョンが[`split-merge-interval`](/pd-configuration-file.md#split-merge-interval)の値 (デフォルトでは`1h` ) を超えて存在する場合、次の条件が同時に発生した場合、このリージョンはリージョンのマージ スケジューリングをトリガーします。

-   このリージョンのサイズは、 [`max-merge-region-size`](/pd-configuration-file.md#max-merge-region-size)の値よりも小さい (デフォルトで 20 MiB)

-   このリージョンのキーの数は、値[`max-merge-region-keys`](/pd-configuration-file.md#max-merge-region-keys)よりも小さくなっています (デフォルトでは 200,000)。

## クエリのスケジューリング ステータス {#query-scheduling-status}

メトリック、pd-ctl、およびログを使用して、スケジューリング システムのステータスを確認できます。このセクションでは、metrics と pd-ctl のメソッドを簡単に紹介します。詳細は[PD モニタリング メトリック](/grafana-pd-dashboard.md)と[PD Control](/pd-control.md)を参照してください。

### オペレーターの状態 {#operator-status}

**Grafana PD/Operator**ページには、オペレーターに関するメトリックが表示されます。

-   スケジュール担当者作成：担当者作成情報
-   オペレーター終了時間：各オペレーターの実行時間
-   オペレーター・ステップ所要時間: オペレーター・ステップの実行時間

次のコマンドで pd-ctl を使用して演算子をクエリできます。

-   `operator show` : 現在のスケジューリング タスクで生成されたすべてのオペレータを照会します。
-   `operator show [admin | leader | region]` : タイプごとに演算子を照会します

### 残高状況 {#balance-status}

**Grafana PD/ 統計 - Balance**ページには、負荷分散に関するメトリックが表示されます。

-   店舗リーダー・地域スコア：各店舗のスコア
-   店舗のリーダー/地域数: 各店舗のリーダー/地域の数
-   利用可能なストア: 各ストアで利用可能なストレージ

pd-ctl のストア コマンドを使用して、各ストアの残高ステータスを照会できます。

### ホットリージョンのステータス {#hot-region-status}

**Grafana PD/ 統計 - hotspot**ページには、ホット リージョンに関するメトリックが表示されます。

-   ホット ライト リージョンのリーダー/ピア ディストリビューション: ホット ライト リージョンのリーダー/ピア ディストリビューション
-   ホットリード領域のリーダー分布: ホットリード領域のリーダー分布

次のコマンドで pd-ctl を使用して、ホット リージョンのステータスを照会することもできます。

-   `hot read` : ホット読み取り領域を照会します
-   `hot write` : ホット ライト領域を照会します
-   `hot store` : 店舗別のホット地域の分布を問い合わせる
-   `region topread [limit]` : 読み取りトラフィックが多いリージョンを照会します
-   `region topwrite [limit]` : 書き込みトラフィックが多いリージョンを照会します

### リージョンの健康 {#region-health}

**Grafana PD/クラスタ/リージョンのヘルス**パネルには、異常な状態のリージョンに関するメトリックが表示されます。

pd-ctl とリージョン チェック コマンドを使用して、異常な状態にあるリージョンのリストを照会できます。

-   `region check miss-peer` : 十分なピアがないリージョンを照会します
-   `region check extra-peer` : 余分なピアを持つリージョンを照会します
-   `region check down-peer` : ピアがダウンしているリージョンを照会します
-   `region check pending-peer` : 保留中のピアがあるリージョンを照会します

## スケジューリング戦略の制御 {#control-scheduling-strategy}

pd-ctl を使用して、次の 3 つの側面からスケジューリング戦略を調整できます。詳細については、 [PD Control](/pd-control.md)を参照してください。

### スケジューラーを手動で追加/削除する {#add-delete-scheduler-manually}

PD は、pd-ctl を介して直接スケジューラーを動的に追加および削除することをサポートしています。例えば：

-   `scheduler show` : システムで現在実行中のスケジューラを表示します
-   `scheduler remove balance-leader-scheduler` : balance-leader-scheduler を削除 (無効化) します
-   `scheduler add evict-leader-scheduler 1` : ストア 1 のすべてのリーダーを削除するスケジューラを追加します。

### オペレーターを手動で追加/削除する {#add-delete-operators-manually}

PD は、pd-ctl を介して直接演算子を追加または削除することもサポートしています。例えば：

-   `operator add add-peer 2 5` : ストア 5 のリージョン2 にピアを追加します
-   `operator add transfer-leader 2 5` :リージョン2 のリーダーをストア 5 に移行します。
-   `operator add split-region 2` :リージョン2 を均等なサイズの 2 つのリージョンに分割します。
-   `operator remove 2` :リージョン2 で現在保留中のオペレーターを削除します

### スケジューリング パラメータの調整 {#adjust-scheduling-parameter}

pd-ctl で`config show`コマンドを使用してスケジューリング構成を確認し、 `config set {key} {value}`を使用して値を調整できます。一般的な調整は次のとおりです。

-   `leader-schedule-limit` : リーダー スケジューリングの転送の同時実行性を制御します
-   `region-schedule-limit` : ピア スケジューリングの追加/削除の同時実行性を制御します
-   `enable-replace-offline-replica` : ノードをオフラインにするスケジューリングを有効にするかどうかを決定します
-   `enable-location-replacement` : リージョンの分離レベルを処理するスケジューリングを有効にするかどうかを決定します
-   `max-snapshot-count` : 各ストアのスナップショットの送受信の最大同時実行数を制御します

## 一般的なシナリオでの PD スケジューリング {#pd-scheduling-in-common-scenarios}

このセクションでは、いくつかの典型的なシナリオを通じて、PD スケジューリング戦略のベスト プラクティスを示します。

### リーダー/リージョンが均等に分散されていない {#leaders-regions-are-not-evenly-distributed}

PD の評価メカニズムは、異なるストアのリーダー数とリージョン数がロード バランシング ステータスを完全に反映できないと判断します。そのため、実際の TiKV の負荷やストレージの使用状況から、負荷の偏りがないかを確認する必要があります。

リーダー/地域が均等に分布していないことを確認したら、さまざまな店舗の評価を確認する必要があります。

異なる店舗のスコアが近い場合、PD はリーダー/地域が均等に分布していると誤って信じていることを意味します。考えられる理由は次のとおりです。

-   負荷の不均衡を引き起こすホット リージョンがあります。この場合、 [ホット リージョンのスケジューリング](#hot-regions-are-not-evenly-distributed)に基づいてさらに分析する必要があります。
-   空のリージョンまたは小さなリージョンが多数存在するため、店舗ごとにリーダーの数に大きな差が生じ、 Raftストアに高いプレッシャーがかかります。これは、 [リージョンマージ](#region-merge-is-slow)スケジューリングの時間です。
-   ハードウェアおよびソフトウェア環境は店舗によって異なります。リーダー/リージョンの分布を制御するには、 [負荷分散](#load-balancing)を参照して`leader-weight`と`region-weight`の値を調整します。
-   その他不明な理由。それでも、 `leader-weight`と`region-weight`の値を調整して、リーダー/リージョンの分布を制御できます。

異なる店舗の評価に大きな違いがある場合は、オペレーターの生成と実行に特に焦点を当てて、オペレーター関連の指標を調べる必要があります。 2 つの主な状況があります。

-   オペレータが正常に生成されてもスケジューリング プロセスが遅い場合は、次の可能性があります。

    -   スケジューリング速度は、負荷分散のためにデフォルトで制限されています。通常のサービスに大きな影響を与えることなく、 `leader-schedule-limit`または`region-schedule-limit`をより大きな値に調整できます。また、 `max-pending-peer-count`と`max-snapshot-count`で指定された制限を適切に緩和することもできます。
    -   他のスケジューリング タスクが同時に実行されているため、バランシングが遅くなります。この場合、バランシングが他のスケジューリング タスクよりも優先される場合は、他のタスクを停止するか、速度を制限できます。たとえば、バランシングの進行中に一部のノードをオフラインにすると、両方の操作で`region-schedule-limit`のクォータが消費されます。この場合、スケジューラーの速度を制限してノードを削除するか、単に`enable-replace-offline-replica = false`を設定して一時的に無効にすることができます。
    -   スケジューリング プロセスが遅すぎます。**オペレーターのステップ期間**メトリックをチェックして、原因を確認できます。一般に、スナップショットの送受信を伴わないステップ ( `TransferLeader` 、 `RemovePeer` 、 `PromoteLearner`など) はミリ秒で完了する必要がありますが、スナップショットを含むステップ ( `AddLearner`や`AddPeer`など) は数十秒で完了すると予想されます。持続時間が明らかに長すぎる場合は、TiKV への高圧またはネットワークのボトルネックが原因である可能性があり、特定の分析が必要です。

-   PD は、対応するバランシング スケジューラの生成に失敗します。考えられる理由は次のとおりです。

    -   スケジューラーは活動化されていません。たとえば、対応するスケジューラが削除されるか、その制限が「0」に設定されます。
    -   その他の制約。たとえば、システム内の`evict-leader-scheduler`は、リーダーが対応するストアに移行するのを防ぎます。または、一部のストアがリーダーを拒否するラベル プロパティが設定されています。
    -   クラスタ トポロジからの制限。たとえば、3 つのデータ センターにまたがる 3 つのレプリカのクラスターでは、レプリカの分離により、各リージョンの 3 つのレプリカが異なるデータ センターに分散されます。これらのデータ センター間で店舗の数が異なる場合、スケジューリングは各データ センター内でのみバランスの取れた状態に到達できますが、グローバルにバランスは取れません。

### ノードをオフラインにするのが遅い {#taking-nodes-offline-is-slow}

このシナリオでは、関連するメトリックを通じてオペレーターの生成と実行を調べる必要があります。

オペレータが正常に生成されても、スケジューリング プロセスが遅い場合は、次の理由が考えられます。

-   スケジューリング速度はデフォルトで制限されています。 `leader-schedule-limit`または`replica-schedule-limit`をより大きな値に調整できます。同様に、 `max-pending-peer-count`と`max-snapshot-count`の制限を緩めることを検討できます。
-   他のスケジューリング タスクが同時に実行され、システム内のリソースが競合しています。 [リーダー/リージョンが均等に分散されていない](#leadersregions-are-not-evenly-distributed)の解決策を参照できます。
-   1 つのノードをオフラインにすると、処理対象のリージョン リーダーの数 (3 つのレプリカの構成で約 1/3) が、削除するノードに分散されます。したがって、速度は、この単一ノードによってスナップショットが生成される速度によって制限されます。手動で`evict-leader-scheduler`を追加してリーダーを移行することで、速度を上げることができます。

対応するオペレーターが生成に失敗した場合、次の理由が考えられます。

-   オペレータが停止しているか、 `replica-schedule-limit`が「0」に設定されています。
-   リージョンの移行に適したノードがありません。たとえば、(同じラベルの) 交換ノードの使用可能な容量サイズが 20% 未満の場合、PD はスケジューリングを停止して、そのノードのストレージが不足するのを回避します。このような場合、ノードを追加するか、一部のデータを削除してスペースを解放する必要があります。

### ノードをオンラインにするのが遅い {#bringing-nodes-online-is-slow}

現在、ノードをオンラインにすることは、バランス リージョン メカニズムを通じてスケジュールされています。トラブルシューティングについては、 [リーダー/リージョンが均等に分散されていない](#leadersregions-are-not-evenly-distributed)を参照してください。

### ホット リージョンが均等に分布していない {#hot-regions-are-not-evenly-distributed}

ホット リージョンのスケジュールに関する問題は、通常、次のカテゴリに分類されます。

-   ホット リージョンは PD メトリクスを介して観察できますが、スケジュールの速度は、ホット リージョンの時間内の再配布に追いつくことができません。

    **解決策**: `hot-region-schedule-limit`をより大きな値に調整し、他のスケジューラの制限クォータを減らして、ホット リージョンのスケジューリングを高速化します。または、 `hot-region-cache-hits-threshold`をより小さい値に調整して、トラフィックの変化に対する PD の感度を高めることもできます。

-   単一の領域に形成されたホットスポット。たとえば、小さなテーブルは大量のリクエストによって集中的にスキャンされます。これは、PD メトリックからも検出できます。実際には単一のホットスポットを配布することはできないため、そのような領域を分割するには、手動で`split-region`オペレーターを追加する必要があります。

-   一部のノードの負荷は、TiKV 関連のメトリックから他のノードの負荷よりも大幅に高くなり、システム全体のボトルネックになります。現在、PD はトラフィック分析のみによってホットスポットをカウントしているため、特定のシナリオでは PD がホットスポットを識別できない可能性があります。たとえば、一部の地域で集中的なポイント ルックアップ リクエストがある場合、トラフィックで検出することは明らかではありませんが、それでも高い QPS が主要なモジュールのボトルネックにつながる可能性があります。

    **解決策**: まず、特定のビジネスに基づいてホット リージョンが形成されるテーブルを見つけます。次に、 `scatter-range-scheduler`のスケジューラを追加して、このテーブルのすべての領域を均等に分散させます。 TiDB は、この操作を簡素化するために、HTTP API にインターフェースも提供します。詳細については、 [TiDB HTTP API](https://github.com/pingcap/tidb/blob/master/docs/tidb_http_api.md)を参照してください。

### リージョンのマージが遅い {#region-merge-is-slow}

遅いスケジューリングと同様に、リージョン マージの速度は`merge-schedule-limit`と`region-schedule-limit`の構成によって制限されている可能性が高く、またはリージョン マージ スケジューラが他のスケジューラと競合しています。具体的には、ソリューションは次のとおりです。

-   システムに多数の空の領域があることがメトリックからわかっている場合は、 `max-merge-region-size`と`max-merge-region-keys`をより小さい値に調整してマージを高速化できます。これは、マージ プロセスにレプリカの移行が含まれるため、マージするリージョンが小さいほど、マージが高速になるためです。マージ オペレータがすでに迅速に生成されている場合は、プロセスをさらに高速化するために、 `patrol-region-interval` ～ `10ms`を設定できます (この構成項目のデフォルト値は、v5.3.0 以降のバージョンの TiDB では`10ms`です)。これにより、リージョンのスキャンが高速化されますが、CPU の消費が増えます。

-   多くのテーブルが作成されてから空にされました (切り捨てられたテーブルを含む)。分割テーブル属性が有効になっている場合、これらの空のリージョンはマージできません。この属性を無効にするには、次のパラメーターを調整します。

    -   TiKV: `split-region-on-table` ～ `false`を設定します。パラメータを動的に変更することはできません。
    -   PD: PD Controlを使用して、クラスターの状況に必要なパラメーターを設定します。

        -   クラスターに TiDB インスタンスがなく、値[`key-type`](/pd-control.md#config-show--set-option-value--placement-rules)が`raw`または`txn`に設定されているとします。この場合、 PD は、 `enable-cross-table-merge setting`の値に関係なく、テーブル全体でリージョンをマージできます。 `key-type`パラメータを動的に変更できます。

        {{< copyable "" >}}

        ```bash
        config set key-type txn
        ```

        -   クラスターに TiDB インスタンスがあり、値`key-type`が`table`に設定されているとします。この場合、値`enable-cross-table-merge`が`true`に設定されている場合にのみ、PD はテーブル間でリージョンをマージできます。 `key-type`パラメータを動的に変更できます。

        {{< copyable "" >}}

        ```bash
        config set enable-cross-table-merge true
        ```

        変更が反映されない場合は、 [FAQ - TiKV/PD 用に変更された`toml`構成が有効にならないのはなぜですか?](/faq/deploy-and-maintain-faq.md#why-the-modified-toml-configuration-for-tikvpd-does-not-take-effect)を参照してください。

        > **ノート：**
        >
        > Placement Rules を有効にした後、値`key-type`を適切に切り替えて、デコードの失敗を回避してください。

v3.0.4 および v2.1.16 以前の場合、特定の状況 (ほとんどの場合、テーブルの削除後に発生する) では、領域の`approximate_keys`が不正確になり、キーの数が`max-merge-region-keys`の制約を破ります。この問題を回避するには、 `max-merge-region-keys`をより大きな値に調整します。

### TiKV ノードのトラブルシューティング {#troubleshoot-tikv-node}

TiKV ノードに障害が発生した場合、PD はデフォルトで 30 分後に対応するノードを**ダウン**状態に設定し (構成項目`max-store-down-time`でカスタマイズ可能)、関連するリージョンのレプリカを再調整します。

実際には、ノードの障害が回復不能と見なされた場合は、すぐにオフラインにすることができます。これにより、PD はすぐに別のノードでレプリカを補充し、データ損失のリスクを軽減します。対照的に、ノードが回復可能と見なされても、回復が 30 分以内に実行できない場合は、一時的に`max-store-down-time`をより大きな値に調整して、レプリカの不要な補充とタイムアウト後のリソースの浪費を回避できます。

TiDB v5.2.0 では、TiKV は遅い TiKV ノード検出のメカニズムを導入します。 TiKV でリクエストをサンプリングすることにより、このメカニズムは 1 から 100 の範囲のスコアを計算します。スコアが 80 以上の TiKV ノードは低速としてマークされます。 [`evict-slow-store-scheduler`](/pd-control.md#scheduler-show--add--remove--pause--resume--config--describe)を追加すると、低速ノードを検出してスケジュールできます。 TiKV が 1 つだけ遅いと検出され、遅いスコアが上限 (デフォルトでは 100) に達した場合、このノードのリーダーは削除されます ( `evict-leader-scheduler`の効果と同様)。

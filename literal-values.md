---
title: Literal Values
summary: This article introduces the literal values ​​of TiDB SQL statements.
---

# リテラル値 {#literal-values}

TiDB のリテラル値には、文字リテラル、数値リテラル、時刻と日付のリテラル、16 進数、バイナリ リテラル、および NULL リテラルが含まれます。このドキュメントでは、これらの各リテラル値を紹介します。

このドキュメントでは、文字列リテラル、数値リテラル、NULL 値、16 進数リテラル、日付と時刻リテラル、ブール値リテラル、およびビット値リテラルについて説明します。

## 文字列リテラル {#string-literals}

文字列は、一重引用符`'`または二重引用符`"`文字で囲まれた一連のバイトまたは文字です。例えば：

```
'example string'
"example string"
```

隣り合って配置された引用符で囲まれた文字列は、1 つの文字列に連結されます。次の行は同等です。

```
'a string'
'a' ' ' 'string'
"a" ' ' "string"
```

`ANSI_QUOTES` SQL MODE が有効な場合、二重引用符で囲まれた文字列は識別子として解釈されるため、文字列リテラルは単一引用符でのみ引用できます。

文字列は、次の 2 つのタイプに分けられます。

-   バイナリ文字列: 文字セットと照合順序が両方とも`binary`である一連のバイトで構成され、相互に比較するときに**バイト**を単位として使用します。
-   非バイナリ文字列: 一連の文字で構成され、 `binary`以外のさまざまな文字セットと照合順序があります。相互に比較すると、非バイナリ文字列は**文字**を単位として使用します。文字セットによっては、文字に複数のバイトが含まれる場合があります。

文字列リテラルには、特定の文字セットと照合順序を使用する文字列として指定するために、オプションの`character set introducer`と`COLLATE clause`を含めることができます。

```
[_charset_name]'string' [COLLATE collation_name]
```

例えば：

```
SELECT _latin1'string';
SELECT _binary'string';
SELECT _utf8'string' COLLATE utf8_bin;
```

N&#39;literal&#39; (または n&#39;literal&#39;) を使用して、各国語文字セットで文字列を作成できます。次のステートメントは同等です。

```
SELECT N'some text';
SELECT n'some text';
SELECT _utf8'some text';
```

文字列内のいくつかの特殊文字を表すために、エスケープ文字を使用してエスケープできます。

| エスケープ文字 | 意味                           |
| :------ | :--------------------------- |
| \0      | ASCII NUL (X&#39;00&#39;) 文字 |
| \&#39;  | 一重引用符`'`文字                   |
| \&quot; | 二重引用符`"`文字                   |
| \b      | バックスペース文字                    |
| \n      | 改行 (改行) 文字                   |
| \r      | 復帰文字                         |
| \t      | タブ文字                         |
| \z      | アスキー 26 (Ctrl + Z)           |
| \\      | バックスラッシュ`\`文字                |
| \%      | `%`文字                        |
| \_      | `_`文字                        |

`'`で囲まれた文字列で`"`を表したり、 `"`で囲まれた文字列で`'`を表したりする場合は、エスケープ文字を使用する必要はありません。

詳細については、 [MySQL の文字列リテラル](https://dev.mysql.com/doc/refman/5.7/en/string-literals.html)を参照してください。

## 数値リテラル {#numeric-literals}

数値リテラルには、整数リテラル、DECIMAL リテラル、および浮動小数点リテラルが含まれます。

整数には、小数点記号として`.`を含めることができます。数値の前に`-`または`+`を付けて、それぞれ負または正の値を示すことができます。

正確な値の数値リテラルは`1, .2, 3.4, -5, -6.78, +9.10`として表すことができます。

数値リテラルは、 `1.2E3, 1.2E-3, -1.2E3, -1.2E-3`などの科学表記法で表すこともできます。

詳細については、 [MySQL の数値リテラル](https://dev.mysql.com/doc/refman/5.7/en/number-literals.html)を参照してください。

## 日付と時刻のリテラル {#date-and-time-literals}

日付と時刻のリテラル値は、引用符付き文字列や数値など、いくつかの形式で表すことができます。 TiDB が日付を予期する場合、 `'2017-08-24'` 、 `'20170824'` 、および`20170824`のいずれかを日付として解釈します。

TiDB は、次の日付形式をサポートしています。

-   `'YYYY-MM-DD'`または`'YY-MM-DD'` : ここでの`-`区切り文字は厳密ではありません。任意の句読点を使用できます。たとえば、 `'2017-08-24'` 、 `'2017&08&24'` 、 `'2012@12^31'`はすべて有効な日付形式です。唯一の特別な句読点は「.」で、整数部分と小数部分を区切る小数点として扱われます。日付と時刻は、 `T`または空白で区切ることができます。たとえば、 `2017-8-24 10:42:00`と`2017-8-24T10:42:00`は同じ日付と時刻を表します。
-   `'YYYYMMDDHHMMSS'`または`'YYMMDDHHMMSS'` : たとえば、 `'20170824104520'`と`'170824104520'`は`'2017-08-24 10:45:20'`と見なされます。ただし、 `'170824304520'`などの範囲外の値を指定すると、有効な日付として扱われません。 `YYYYMMDD HHMMSS` 、 `YYYYMMDD HH:MM:DD` 、または`YYYY-MM-DD HHMMSS`などの不適切な形式は挿入に失敗することに注意してください。
-   `YYYYMMDDHHMMSS`または`YYMMDDHHMMSS` : これらの形式には、一重引用符または二重引用符はなく、数値であることに注意してください。たとえば、 `20170824104520`は`'2017-08-24 10:45:20'`と解釈されます。

DATETIME または TIMESTAMP 値の後には、マイクロ秒の精度 (6 桁) を表すために使用される小数部を続けることができます。小数部は、常に小数点`.`で残りの時間と区切る必要があります。

2 桁だけの年の値はあいまいです。 4 桁の年形式を使用することをお勧めします。 TiDB は、次の規則に従って 2 桁の年の値を解釈します。

-   年の値が`70-99`の範囲内にある場合は、 `1970-1999`に変換されます。
-   年の値が`00-69`の範囲内にある場合は、 `2000-2069`に変換されます。

月または日の値が 10 未満の場合、 `'2017-8-4'`は`'2017-08-04'`と同じです。時間についても同様です。たとえば、 `'2017-08-24 1:2:3'`は`'2017-08-24 01:02:03'`と同じです。

日付または時刻の値が必要な場合、TiDB は値の長さに応じて指定された形式を選択します。

-   6 桁: `YYMMDD` .
-   12 桁: `YYMMDDHHMMSS` .
-   8 桁: `YYYYMMDD` .
-   14 桁: `YYYYMMDDHHMMSS` .

TiDB は、時間値の次の形式をサポートしています。

-   `'D HH:MM:SS'` 、 `'SS'` `'HH:MM:SS'` `'D HH'`は`'HH:MM'` `D`意味し、有効な値の範囲は`'D HH:MM'` `0-34` 。
-   `HHMMSS`形式の数値: たとえば、 `231010`は`'23:10:10'`と解釈されます。
-   `SS` 、 `MMSS` 、および`HHMMSS`のいずれかの形式の数値を時間と見なすことができます。

Time 型の小数点も`.`で、小数点以下 6 桁までの精度です。

詳細については、 [MySQL の日付と時刻のリテラル](https://dev.mysql.com/doc/refman/5.7/en/date-and-time-literals.html)を参照してください。

## ブール値リテラル {#boolean-literals}

定数`TRUE`と`FALSE`はそれぞれ 1 と 0 に等しく、大文字と小文字は区別されません。

{{< copyable "" >}}

```sql
SELECT TRUE, true, tRuE, FALSE, FaLsE, false;
```

```
+------+------+------+-------+-------+-------+
| TRUE | true | tRuE | FALSE | FaLsE | false |
+------+------+------+-------+-------+-------+
|    1 |    1 |    1 |     0 |     0 |     0 |
+------+------+------+-------+-------+-------+
1 row in set (0.00 sec)
```

## 16 進リテラル {#hexadecimal-literals}

16 進数のリテラル値は、 `X'val'`または`0xval`表記を使用して記述されます`val`には 16 進数が含まれます。先頭の`0x`は大文字と小文字が区別され、 `0X`のように書くことはできません。

有効な 16 進数リテラル:

```
X'ac12'
X'12AC'
x'ac12'
x'12AC'
0xac12
0x12AC
```

不正な 16 進数リテラル:

```
X'1z' (z is not a hexadecimal legal digit)
0X12AC (0X must be written as 0x)
```

`X'val'`表記を使用して記述された 16 進リテラルには、偶数の桁数が含まれている必要があります。 `val`の長さが奇数 (たとえば、 `X'A'`または`X'11A'` ) の場合、構文エラーを回避するために、値の前にゼロを追加します。

```sql
mysql> select X'aff';
ERROR 1105 (HY000): line 0 column 13 near ""hex literal: invalid hexadecimal format, must even numbers, but 3 (total length 13)
mysql> select X'0aff';
+---------+
| X'0aff' |
+---------+
| 0x0aff  |
+---------+
1 row in set (0.00 sec)
```

デフォルトでは、16 進リテラルはバイナリ文字列です。

文字列または数値を 16 進数形式の文字列に変換するには、 `HEX()`関数を使用します。

```sql
mysql> SELECT HEX('TiDB');
+-------------+
| HEX('TiDB') |
+-------------+
| 54694442    |
+-------------+
1 row in set (0.01 sec)

mysql> SELECT X'54694442';
+-------------+
| X'54694442' |
+-------------+
| TiDB        |
+-------------+
1 row in set (0.00 sec)
```

## ビット値リテラル {#bit-value-literals}

ビット値リテラルは、 `b'val'`または`0bval`表記を使用して記述されます。 `val`は、0 と 1 を使用して書かれたバイナリ値です。先頭の`0b`は大文字と小文字が区別され、 `0B`のように書くことはできません。

正当なビット値リテラル:

```
b'01'
B'01'
0b01
```

不正なビット値リテラル:

```
b'2' (2 is not a binary digit; it must be 0 or 1)
0B01 (0B must be written as 0b)
```

デフォルトでは、ビット値リテラルはバイナリ文字列です。

ビット値はバイナリ値として返されるため、MySQL クライアントではうまく表示されない場合があります。ビット値を印刷可能な形式に変換するには、 `BIN()`や`HEX()`などの変換関数を使用できます。

```sql
CREATE TABLE t (b BIT(8));
INSERT INTO t SET b = b'00010011';
INSERT INTO t SET b = b'1110';
INSERT INTO t SET b = b'100101';

mysql> SELECT b+0, BIN(b), HEX(b) FROM t;
+------+--------+--------+
| b+0  | BIN(b) | HEX(b) |
+------+--------+--------+
|   19 | 10011  | 13     |
|   14 | 1110   | E      |
|   37 | 100101 | 25     |
+------+--------+--------+
3 rows in set (0.00 sec)
```

## NULL 値 {#null-values}

`NULL`はデータが空であることを意味し、大文字と小文字は区別されず、 `\N` (大文字と小文字を区別) と同義です。

> **ノート：**
>
> `NULL`は`0`や空の文字列`''`と同じではありません。
